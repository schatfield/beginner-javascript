<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width,initial-scale=1.0">
  <title>

  </title>
  <link rel="stylesheet" href="../../base.css">
</head>

<body>
  <script>
    const toppings = ['Mushrooms ', 'Tomatoes', 'Eggs', 'Chili', 'Lettuce', 'Avocado', 'Chiles', 'Bacon', 'Pickles', 'Onions', 'Cheese'];

    const buns = ['egg', 'wonder', 'brioche'];

    const meats = {
      beyond: 10,
      beef: 5,
      pork: 7
    };

    const prices = {
      hotDog: 453,
      burger: 765,
      sausage: 634,
      corn: 234,
    };

    const orderTotals = [342, 1002, 523, 34, 634, 854, 1644, 2222];

    const feedback = [
      { comment: 'Love the burgs', rating: 4 },
      { comment: 'Horrible Service', rating: 2 },
      { comment: 'Smoothies are great, liked the burger too', rating: 5 },
      { comment: 'Ambiance needs work', rating: 3 },
      { comment: 'I DONT LIKE BURGERS', rating: 1 },
    ];


    /*
      Static Methods - aren't available on every array you create. Utility methods
    */ //They live on Array.of, Array.from

    // Array.of(); - used for creating an array from it's arguments
    const arrayOf = Array.of('wes', 'kait');
    console.log(arrayOf);

    
    //Array.from will take an iterable or something with a length and it returns to you an array with whatever the length is that you gave it.
    //for example Array.from ({ length:10 }) returns an empty array with a length of 10
    //Array.from takes a secondary argument which is called a Map argument. it's a function that will put in those empty slots you made
    //create an array with 10 spots and then fill it with whatever you return from the callback function


    // Make a function that creates a range from x to y with Array.from(); 
  function creatRange(start, end) {
    const range = Array.from({ length: end - start }, function(item, index) {
      return index;
      });
      return range;
    };

  const myRange = creatRange(3,7);

    // Check if the last array you created is really an array with Array.isArray();

    console.log(Array.isArray(myRange));

    // Take the meats object and make three arrays with Object.entries(), Object.keys, Object.values()

    //if you pass these static helper methods of.entries, .keys, .values an object, they will return an array of the thing you ran on the object
    //for example Object.keys() returns and array of all the keys in the meat object

    //entries gives us an array where each item is a nested array that has the key and the value, so we get 3 nested arrays
    console.log(Object.entries(meats))
    console.log(Object.keys(meats))
    console.log(Object.values(meats))
//loop that returns the values of each key- the quantities of each meat
    Object.values(meats).forEach(qty => {
      console.log(qty);
    });

    Object.entries(meats).forEach(entry => {
      //const key = entry[0];
      //const value = entry[1];
      const [key, value] = entry;
      console.log(key, value);
    });
    /*
      Instance Methods - methods that live on each array and are aviable to us
    */

    //.join() turns an array into a string joining each item with a comma
    //it takes an argument of what you want to "join" the items on

    // Display all bun types with " or " - use join()
    //spaces around ' or ' create spaces in the string like a sentence
    console.log(buns.join( ' or ' ));

    // We have a string "hot dogs,hamburgers,sausages,corn" - use split() to turn it into an array
    //.split  is a string method, it will split what ever you pass into it into an array
    const foodString = "hot dogs,hamburgers,sausages,corn";
    console.log(foodString.split(','))

    // take the last item off toppings with pop()
    const lastItem = toppings.pop();
    console.log(lastItem);
    // add it back with push()
    toppings.push(lastItem);
    console.log(toppings);
    // take the first item off toppings with shift()
    const firstItem = toppings.shift();
    console.log(firstItem);
    console.log(toppings);
    // add it back in with unshift()
    toppings.unshift(firstItem);
    console.log(toppings);

    // Do the last four exercises again (do what pop, push, shift, unshift do) ,but immutable (with spreads and new variables)
    //we will use .slice as it is immutable and the original array will NOT be changed
    //.slice method- let's us take a portion of the original array and turn that portion into our own new one

    let newToppings = toppings.slice(0, toppings.length - 1)
    // toppings[toppings.length -1] adds on the last item - cheese
    newToppings = [...newToppings, toppings[toppings.length - 1]];
    console.log(newToppings);


    // Make a copy of the toppings array with slice()
    const toppingCopy = toppings.slice(0);
   // toppings[0] = "shoo";
   // console.log(toppings);
    console.log(toppingCopy);
    // Make a copy of the toppings array with a spread
    const toppingsCopy2 = [...toppings];
    console.log(toppingsCopy2);
    // take out items 3 to 5 from your new toppings array with splice()
    //splice is mutable
    toppingCopy.splice(3,5);
    console.log(toppingCopy);
    console.log(toppings);
    // find the index of Avocado with indexOf() / lastIndexOf()
    const indexAvo = toppings.indexOf('Avocado');
    console.log(indexAvo);
    const shawna = { name: 'shawna' }
    const people = [{ name: 'scott' }, shawna];
    console.log(people.indexOf(shawna));
    // Check if hot sauce is in the toppings with includes()
    // add it if it's not

    const isInToppings = toppings.includes('Hot Sauce');
    console.log(isInToppings);
    //if hot sauce is NOT included
    if (!isInToppings) {
      toppings.push('Hot Sauce');
    }
    console.log(toppings);
    // flip those toppings around with reverse()
    //mutable version- original toppings array will be changed
    //toppings.reverse();
    //console.log(toppings);
    //immutable solution
    const toppingsReversed = [...toppings].reverse();
    console.log(toppingsReversed);
    console.log(toppings);

    /*
      Callback Methods - this is a made up term, but a lot of these methods take a function as an argument called a CAllBACK 
    */

    // find the first rating that talks about a burger with find()
    //the argument of find is going to be a function (callback functions are functions that take a function as an argument) that will either return true or false when it has found the item that it wants

//first arg is representing each individual item in the array (the first arg is known in the docs as the element- we are naming it what it is "feedback". ask yourself- what is each individual thing in the array I am dealing with? in this case it's individual feedbacks.

//second arg is the index if you need to knwo what index position smething is, and the third is the entire array if you ever need to reference the entire array while you're inside of it

  //function findBurgerRating(feedback) {
    //condition- something that tests is something is true or false
    //because .includes is a mthod that only ever returns true or false we don't need an if statement and return and true and false oursleves, we can do it this way instead
    //return feedback.comment.includes('burg'); 
  //}

//Arrow function syntax
  //const findBurgerRating = (feedback) => {
    //return feedback.comment.includes('burg'); 
//}

//function inside of an object - Makes it a METHOD 
//you could now pass util.findBurgerRating 
const util = {
  findBurgerRating:  function (feedback) {
    return feedback.comment.includes('burg');
  }
}

const findSmoothieRating = function (feedback) {
    return feedback.comment.includes('Smoothie');
  }

//here's a function that will create the functions above for us- it will create a function for each keyword we are trying to find 
//it's a function that returns a function
function findByWord(word) {
  return function (feedback) {
    return feedback.comment.includes(word);
  }
}

//notice we dont call the function we passed, we are just passing reference to the function- it's because JS itself will run it once for each of the feedbacks in our feedback array .find is expecting a function as an arg 
  const burgerRating = feedback.find(util.findBurgerRating);
  console.log(burgerRating);
  const smoothieRating = feedback.find(findSmoothieRating);
  console.log(smoothieRating);

    // find all ratings that are above 2 with filter()
    // find all ratings that talk about a burger with filter()
    // Remove the one star rating however you like!

    // check if there is at least 5 of one type of meat with some()
    // make sure we have at least 3 of every meat with every()
    // sort the toppings alphabetically with sort()
    // sort the order totals from most expensive to least with .sort()
    // Sort the prices with sort()

    /*
      Looping Methods (next)
    */

  </script>
</body>

</html>
